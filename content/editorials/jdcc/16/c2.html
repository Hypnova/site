+++
title = "JDCC 2016 December Editorials"

+++

<div class="row">
  <ol class="breadcrumb">
    <li><a href="/">Home</a></li>
    <li><a href="/editorials">Editorials</a></li>
    <li><a href="/editorials/jdcc">JDCC</a></li>
    <li><a href="/editorials/jdcc/16">2016</a></li>
    <li class="active">December</li>
  </ol>
</div>

<div class="row">
  <h1>JDCC 2016 December Editorials</h1>
  <hr>
  
  <h2 class="h2-responsive">Problems</h2>
  
  <ol type="A" class="large-list">
    <li><a href="#a">Simplify</a></li>
    <li><a href="#b">Broken Telephone</a></li>
    <li><a href="#c">Shoe Rental</a></li>
    <li><a href="#d">Pokemon Woes</a></li>
    <li><a href="#e">Supermoon Viewing</a></li>
  </ol>
  
  <hr>
</div>

<div class="row editorial-title" id="a">
  <h1 class="h1-responsive">Simplify <a href="/problems/jdcc16c2a"><small class="text-muted">jdcc16c2a</small></a></h1>
  <i class="fa fa-pencil"></i><user>aurpine</user>
  <hr>
</div>

<div class="row">
  <p>Use two variables, the earliest year and name of the person, to store the currently first person to discover the theorem. Loop through the mathematicians and override the current person if the year of the current person is less than the one stored. </p>

  <h3 class="h3-responsive">Time Complexity</h3>
  <p>\(\mathcal O(N)\)</p>
</div>

<div class="row editorial-title" id="b">
  <h1 class="h1-responsive">Broken Telephone <a href="/problems/jdcc16c2a"><small class="text-muted">jdcc16c2b</small></a></h1>
  <i class="fa fa-pencil"></i><user>aurpine</user>
  <hr>
</div>

<div class="row">
  <p>One part of the problem is the input. By reading in hours and minutes, make a function that converts hours and minutes to minutes past 9:00. To output, hours is seconds divided by 60, and seconds is second mod 60. This makes the rest of the problem easier. </p>
  
  <p>Store the latest ending time of a meeting so far (initialize to 9:00) and override as necessary. Keep a variable for the amount of wasted time (in seconds). If the current meeting's start time is after the latest ending time, then add the difference to the wasted time. </p>

  <h3 class="h3-responsive">Time Complexity</h3>
  <p>\(\mathcal O(N)\)</p>
</div>

<div class="row editorial-title" id="c">
  <h1 class="h1-responsive">Shoe Rental <a href="/problems/jdcc16c2c"><small class="text-muted">jdcc16c2c</small></a></h1>
  <i class="fa fa-pencil"></i><user>aurpine</user>
  <hr>
</div>

<div class="row">
  <p>Read the input and store in a 2D array. Then loop through each square of 4 and count the number of unique squares. You can do this easily (but not necessarily efficiently) with a set. </p>

  <h3 class="h3-responsive">Time Complexity</h3>
  <p>\(\mathcal O(RC)\)</p>
</div>

<div class="row editorial-title" id="d">
  <h1 class="h1-responsive">Pokemon Woes <a href="/problems/jdcc16c2d"><small class="text-muted">jdcc16c2d</small></a></h1>
  <i class="fa fa-pencil"></i><user>atarw</user>
  <hr>
</div>

<div class="row">
  <p>First, calculate the distance between each pair of Pokemon present on the map, as well as Ash's home to each Pokemon, and store this in an array. Distances can be calculated using this formula: \(|x_{1} - x_{2}| + |y_{1} - y_{2}|\), where \((x_{1}, y_{1})\) and \((x_{2}, y_{2})\) are two coordinate locations.</p>
    
  <p>Next, we must try out various orders in which Ash can visit all the points, and choose the one which gives the minimum total distance. This is done using DFS, where the parameters passed in are the current location of Ash, and the Pokemon locations that have already been visited.</p>
    
  <p>To speed this up, use dynamic programming to store results calculated by the DFS. To do so, the Pokemon locations that have already been visited can be represented in binary, with the \(i^{th}\) bit being a \(0\) or \(1\) to represent whether or not the \(i^{th}\) Pokemon has already been visited.</p>

  <h3 class="h3-responsive">Time Complexity</h3>
  <p>\(\mathcal O(N^2 + M2^M)\), where \(M\) is the number of Pokemon on the map.</p>
</div>

<div class="row editorial-title" id="e">
  <h1 class="h1-responsive">Supermoon Viewing <a href="/problems/jdcc16c2e"><small class="text-muted">jdcc16c2e</small></a></h1>
  <i class="fa fa-pencil"></i><user>atarw</user>
  <hr>
</div>

<div class="row">
  <p>Observe that because every single character in the given string must be part of the pattern, it doesn't matter which pattern you find in the string, as long as it repeats throughout. To find the repeated pattern, take the first character of the string and iterate through the string until the next occurrence of it is found.
    
  <p>Here, check if the substring between the two identical characters is the repeated pattern. This can be done by iterating through the string and ensuring that the pattern is repeated throughout (you only need to go through half the string because the pattern is guaranteed to repeat at least twice in the string).</p>
  
  <p>If the pattern is not repeated, this means that the pattern is not between the two identical characters. Keep iterating through the string until the identical character is found again, and perform the pattern check detailed above until the pattern is found.</p>
  
  <p>Once the pattern is found, use simple math to determine how many times the pattern was repeated in the string, and which five characters from the pattern to output.</p>
  
  <h3 class="h3-responsive">Time Complexity</h3>
  <p>\(\mathcal O(N^2)\) because in the worst case, half of the string will be iterated through for each character of the string in the first half of the string. However, such a string does not exist and the true running time is most likely closer to (but not quite) \(\mathcal O(N)\).</p>
</div>